package array;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

//剑指 Offer 40. 最小的k个数
public class getLeastNumbers {
    public static void main(String[] args) {
        int[] arr =new int[]{0,1,0,2,1,3,1,5,6,1,9,5,5,1,6,13,15,14,12,19,15,16,17,3,8,1,3,11,5,
                6,27,31,11,6,22,4,32,25,37,32,16,4,15,4,30,17,1,4,2,17,21,18,26,23,11,30,2,33,41,
                41,60,50,28,30,34,49,49,24,16,43,21,24,30,65,35,12,44,38,52,38,69,32,81,16,34,54,
                26,74,68,87,69,85,23,16,57,48,33,81,71,16,100,51,36,83,87,47,7,12,27,28,69,14,20,
                103,18,106,98,20,5,22,17,9,114,10,63,9,122,84,114,6,22,70,107,107,7,51,114,45,81,
                93,58,26,4,92,21,140,89,20,83,40,35,74,112,106,62,59,146,9,134,156,24,38,148,128,
                86,121,87,37,142,83,36,68,147,56,133,167,67,91,148,79,100,174,103,138,81,142,24,
                108,150,64,7,14,89,148,109,180,167,42,158,182,100,21,112,106,188,8,206,124,99,204,
                18,25,112,39,173,92,168,155,170,85,195,84,136,153,28,92,67,140,203,156,107,146,201,
                85,131,33,193,55,228,68,27,22,79,74,51,170,232,194,7,90,22,182,168,150,79,49,95,146,15,236,30,224,130,216,83,150,84,260,99,238,213,242,180,57,158,99,224,47,95,108,152,144,254,112,189,80,169,56,1,66,92,105,39,259,97,175,245,31,47,211,89,278,5,112,249,281,296,48,257,110,47,183,29,238,158,110,313,9,237,4,14,155,321,52,80,78,135,49,280,127,276,29,164,329,81,67,110,115,11,301,151,216,65,211,152,38,15,77,70,319,343,98,333,91,237,330,175,187,174,63,179,237,129,302,121,86,22,61,69,97,254,57,348,167,96,182,370,346,87,168,181,328,322,142,323,253,51,14,345,232,220,229,262,337,97,209,102,263,39,273,218,28,133,252,402,84,151,204,315,183,400,357,60,211,307,181,125,109,189,392,328,292,135,218,140,187,302,395,338,192,35,156,191,298,1,189,120,1,242,44,371,8,74,305,307,154,398,22,268,221,109,54,241,346,112,329,114,414,429,114,157,36,254,361,300,320,136,312,407,106,165,221,80,3,386,292,15,111,25,258,337,60,288,221,303,362,185,163,345,28,69,328,447,479,292,222,195,234,454,44,70,459,422,174,164,368,256,145,298,34,287,410,256,278,293,282,307,82,79,458,312,65,505,171,498,506,491,213,407,391,65,349,390,263,365,302,349,478,454,468,322,350,166,445,2,301,424,473,429,178,489,28,269,63,161,199,364,493,556,242,21,195,273,518,555,542,532,233,129,123,217,22,79,246,373,220,21,48,68,167,562,242,454,462,478,296,229,392,490,398,583,278,180,136,196,493,220,576,226,515,44,563,106,452,219,413,373,331,496,188,140,305,222,127,46,271,98,523,503,307,152,478,166,496,283,33,507,495,496,9,527,422,273,20,73,142,112,586,195,81,267,407,320,380,94,494,510,445,394,402,469,173,345,438,69,92,122,229,434,576,458,44,588,501,603,644,604,651,242,255,493,174,57,102,419,266,583,286,637,662,488,543,61,93,639,535,490,310,77,328,73,58,482,676,36,255,512,246,593,691,41,519,550,32,155,344,452,383,704,609,350,332,64,461,338,498,3,394,126,500,387,80,257,647,682,318,202,297,123,449,249,531,127,698,9,496,219,623,476,146,424,332,372,27,327,681,265,628,69,627,225,492,354,616,389,104,584,608,559,237,283,89,352,654,626,152,650,314,310,578,764,133,432,145,722,176,87,26,268,583,590,659,321,12,192,535,522,279,271,707,341,193,182,560,754,149,305,258,429,512,116,266,655,555,720,530,469,102,156,597,359,129,467,791,710,18,769,252,818,638,687,421,520,678,273,214,56,161,635,810,154,108,623,51,456,611,168,446,12,323,528,414,608,201,632,90,147,140,655,696,590,73,252,678,636,16,392,675,497,185,332,58,563,473,339,308,350,784,781,504,514,847,688,833,520,409,360,774,373,264,174,213,442,608,545,24,714,149,816,757,393,106,389,771,182,219,636,93,863,567,34,478,144,371,70,662,607,605,629,416,695,0,405,32,298,493,695,173,451,875,834,20,692,220,862,638,907,587,176,711,451,821,364,469,271,481,188,343,518,800,15,478,651,598,495,348,454,727,570,114,329,849,161,144,124,122,312,140,250,47,868,295,942,706,108,833,297,535,266,49,72,608,567,685,308,737,656,954,636,117,
                836,968,0,490,639,358,948,134,851,520,379,232,531,969,485,591,516,427,512,758};
        int[] arr2 = new int[]{345,5649,3,5,0,-1,6,345,7,9};
        //getLeastNumbers(arr2,5);
        //getLeastNumbers1(arr2,5);
        getLeastNumbers3(arr2,5);
    }

    /**
     * 因为是寻找前k大，所以，由快速排序的思想 变形来的快速选择
     * 找到一个数字作为基准 他的下标定位 m
     * 比m 小的放左边 比 m 大的放右边
     * m == k 那么m 左侧的的就是要找的前k个数字
     * m > k 那么说明m左侧 小于m的数字个数比k多 那么继续对左边进行partition
     * m < k 那么说明m坐蹙 小于m的数字个数比k小 那么继续对右进行partition 要找到的数字是 k-m
     * @param arr
     * @param k
     * @return
     */
    public static int[] getLeastNumbers3(int[] arr, int k) {
        if(k == 0 || arr.length == 0) {
            return new  int[0];
        }
        if(k >= arr.length) {
            return arr;
        }
        //执行快速选择的逻辑
        //我们要确保某个下标之前有k个元素，
        //那么需要找到分割返回的下标就是k
        //它之前的所有元素就是k个
         return quickSelect(arr,0,arr.length-1,k);
    }

    /**
     * 区间属于全闭区间
     */
    private static int[] quickSelect(int[] arr, int lowIndex, int highIndex, int k) {
        //1.选择一个数字作为基准对数组进行partition
        int index = partition(arr,lowIndex,highIndex,k);
        //2.记录partition之后返回的下标
        if(index == k ){
            //那么说明找到了就可以返回数组了只是需要对数组拷贝一份
            int[] res = Arrays.copyOf(arr,k);//新数组的长度
            return res;
        }
        if(index > k){
            //需要继续在左侧查找
             return quickSelect(arr,lowIndex,index-1,k);
        }else {  //(index < k){
            //说明需要在右侧进行查找
            return quickSelect(arr,index+1,highIndex,k);
        }
    }

    private static int partition(int[] arr, int lowIndex, int highIndex, int k) {
        //选择一个数字对数组进行分割--最左边的
        int v = arr[lowIndex]; //把左下标的元素保存起来
        //然后采用挖坑法把 比v小的放左边 比v 大的放右边
        int leftIndex = lowIndex;
        int rightIndex = highIndex;
        while (leftIndex < rightIndex){
            //从右边先走
            while (leftIndex < rightIndex && arr[rightIndex] >= v ){
                rightIndex--;
            }
            arr[leftIndex] = arr[rightIndex];
            while (leftIndex < rightIndex && arr[leftIndex] < v){
                leftIndex++;
            }
            arr[rightIndex] = arr[leftIndex];
        }
        //最后填充进去
        arr[leftIndex]= v;
        return leftIndex;
    }

    /**
     * 利用java本身的优先级队列来做
     * @param arr
     * @param k
     * @return
     */
    public static int[] getLeastNumbers2(int[] arr, int k) {
        int[] res =  new int[k];
        if(k == 0) return res ;
        //这是java中帮你实现的建堆的操作
        //Java 中提供了现成的 PriorityQueue（默认小根堆）
        PriorityQueue<Integer> heap = new PriorityQueue(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;//这里的操作表示建立大堆
            }
        });

        //然后依次向优先级队列中加入元素
        for(int i =0 ;i <k ;i++){
            heap.offer(arr[i]);
        }
        //如果比堆里面的元素大，就删除堆顶，然后重新向下调整
        for(int i = k;i< arr.length;i++){
            if(arr[i] < heap.peek()){
                heap.poll();
                heap.offer(arr[i]);
            }
        }
        //这里不能实现拷贝，因为拷贝的话实际拷贝的还是源数组，不是堆里面的元素

        for(int i = 0; i< k;i++){
            res[i] = heap.poll();
        }
        return res;
    }
    /**
     * 就是尽量不建议自己来实现建堆的操作
     * java中的实现类优先级队列可以帮助你做到
     * 建堆的操作
     * 先用前k个数字建立一个大堆，如果比下一个数字比堆顶大，那么就替换堆顶，然后进行一次向下调整的过程
     * 自己写的这个虽然没有过oj但是基本没错，只是说leetode对输入和输出有限制 要求相同的必须排列在一起的问题
     */
    public static int[] getLeastNumbers1(int[] arr, int k) {
        //如何利用前k个数字建立一个大堆
        //堆的本质是一个数组，要进行建堆的操作，首先从第一个非叶子结点进项一次向下调整直到数组的第一个元素
        //堆里面一共有k个元素，那么最后一个下标
        int heapLastIndex = k-1;
        int parentIndex = (heapLastIndex-1)/2;
        //建立大堆的操作就是从第一个非叶子结点开始
        for(int i = parentIndex;i >= 0;i --){
            //进行向下调整的过程
            shiftDown(arr,i, k); // 传递的参数 数组，需要调整的位置，以及数组的大小
        }
        //然后依次进行比较的操作，如果比堆顶小就交换
        for(int i = k;i< arr.length;i++){
            if(arr[i] < arr[0]){
                arr[0] = arr[i];
                //然后再次建立大堆
                shiftDown(arr,0,k);
            }
        }

        //这个可以拷贝，因为你的更改是在源数组上的
        //最后输出前k个数字即可
        int[] res = new int[k];
        res = Arrays.copyOf(arr,k);
        return res;

    }

    /**
     * 建立大堆
     * 堆的本质一定是一颗完全二叉树
     */
    private static void shiftDown(int[] arr, int index, int size) {
        //如果要调整的结点是叶子结点 那么就return
        //如何判断是不是叶子结点，就看它有没有左孩子
        if(2*index >= size ) return;
        //如果不是的话，就需要找出他的左右孩子的最大值，然后交换
        int maxIndex = 2*index+1;
        int rightIndex = maxIndex+1;
        //如果右孩子存在，并并且值大
        if(rightIndex < size && arr[rightIndex] > arr[maxIndex]){
            maxIndex = rightIndex;
        }
        if(arr[index] >= arr[maxIndex])  return;
        //执行交换的逻辑
        int temp = arr[index];
        arr[index] = arr[maxIndex];
        arr[maxIndex] = temp;
        shiftDown(arr,maxIndex,size);
    }
}
