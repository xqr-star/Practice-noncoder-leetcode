package Leetcode;

//区间DP 91. 解码方法
public class numDecoding {
    public static void main(String[] args) {
        System.out.println(numDecoding("12"));
    }

    /**
     * 区间DP DP 是有限制的
     * s = "12"
     * 输出：2
     * 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
     * 由字符 解析成 字母 解析的最后一个字母就是最后一个状态
     * 也就是说一个字符串可以解析成不同字母序列的个数
     * 一维
     * 状态表示 f[i]
     *      状态集合：所有由前i个字符可以解码得到的 不同字母 序列的个数
     *      属性：数量
     * 状态转移 往往考虑的是最后一步 最后一个字母 (最后一个字母可以由最后一个字符或者是倒数的两个字符解析得到)
     *  f[i] = f[i-1] + f[i-2]
     *
     *  但是会产生边界的情况以及dp限定的问题
     *  一个字符的时候 字符不可以是0
     *  两个字符的时候，字符不可以超过26
     *
     *  前i个字符构成字母序列的个数 = 前i-1个字符构成的字母序列个数 + 前i-2个字符构成的字母序列个数
     *  dp[i] = dp[i-1] + dp[i-2]
     *
     *
     * 设置dp的下标从1开始 0是边界
     *  i = 0
     *  i = 1
     *
     * @param s
     * @return
     */
    public  static int numDecoding(String s) {
        int n = s.length();
        //为了处理边界不麻烦 所以多开辟一个数字
        int[] dp = new int[n+1];

        //初始化状态 --这个是dp的边界
        //用0个数字可以得到的字符串是0 就是空串 -- 虽然我觉的他的解释不对
        dp[0] = 1;

        //i 的含义表示的是前多少个字符
        // 从第一个字符开始算起
        for(int i = 1; i <= n;i++){
            //先看由一个字符构成字母的
            //第i个字符是i-1
            if(s.charAt(i-1) != '0') {
               dp[i] += dp[i - 1]; //表示由前i个字符构成的字母是 前i-可以构成的
            }
            //再看由两位字符解码构成字母的
            //首先得有两个字符
            if(i >= 2){
                //这两个字符转换成整数以后。是否可以 >=10 <= 26
                //然后要看当前的这一个字符 和他的前一个字符构成的数字是否子啊有效的范围内
                int num = (s.charAt(i-2) - '0')*10 + (s.charAt(i-1)-'0');
                if(num >= 10 && num <= 26){
                    dp[i] += dp[i-2];
                }
            }
        }
        return  dp[n];
    }
}
